print('Задача 1. Урок информатики 2')


# В прошлый раз учитель написал программу,
# которая выводит числа в формате плавающей точки, однако он вспомнил,
# что не учёл одну важную штуку: числа-то могут идти от нуля.
# 
# Задано положительное число x (x > 0).
# Ваша задача преобразовать его в формат плавающей точки,
# то есть x = a * 10 ** b, где 1 ≤ а < 10
# 
# Обратите внимание, что x теперь больше нуля, а не больше единицы.
# Обеспечьте контроль ввода.
# 
# Пример 1:
# 
# Введитечисло: 92345
# 
# Формат плавающей точки: x = 9.2345 * 10 ** 4
# 
# Пример 2:
# 
# Введите число: 0.0012
# Формат плавающей точки: x = 1.2 * 10 ** -3

x = float(input("Введите число больше нуля: "))

a = 0
b = 0

if x >= 1:
    while x >= 10:
        x /= 10
        b += 1
else:
    while x < 1:
        x *= 10
        b -= 1

a = x

print(f"x = {a} * 10 ** {b}")

print('Задача 2. Функция максимума')

# Юра пишет различные полезные функции для Python, чтобы остальным программистам
# стало проще работать. Он захотел написать функцию, которая будет находить
# максимум из перечисленных чисел. Функция для нахождения максимума из двух чисел
# у него уже есть. Юра задумался: может быть, её можно как-то использовать для
# нахождения максимума уже от трёх чисел?

# Помогите Юре написать программу, которая находит максимум из трёх чисел.
# Для этого используйте только функцию нахождения максимума из двух чисел.

# По итогу в программе должны быть реализованы две функции:
# 1) maximum_of_two — функция принимает два числа и возвращает
# одно (наибольшее из двух);
# 2) maximum_of_three — функция принимает три числа и возвращает
# одно (наибольшее из трёх); при этом она должна использовать для
# сравнений первую функцию maximum_of_two.

n_1 = float(input("Введите первое число: "))
n_2 = float(input("Введите второе число: "))
n_3 = float(input("Введите третье число: "))

def maximum_of_two(n_1, n_2):
    max_n = 0
    if n_1 < n_2:
        max_n = n_2
    else:
        max_n = n_1
    return max_n

def maximum_of_three(n_3):
    max_digit = 0
    if n_3 > maximum_of_two(n_1, n_2):
        max_digit = n_3
    else:
        max_digit = maximum_of_two(n_1, n_2)
    return max_digit

maximum_of_two(n_1, n_2)
result = maximum_of_three(n_3)
print("Максимальное число:", result)


print('Задача 3. Число наоборот 2')


# Пользователь вводит два числа — N и K.
# Напишите программу,
# которая заменяет каждое число на число,
# которое получается из исходного записью его цифр в обратном порядке,
# затем складывает их,
# снова переворачивает и выводит ответ на экран.

# Пример: 

# Введите первое число: 102
# Введите второе число: 123
 
 
# Первое число наоборот: 201
# Второе число наоборот: 321
 
# Сумма: 522
# Сумма наоборот: 225


n = int(input("Введите первое число: "))

def reverse(n):
    reverse = 0
    while n > 0:
        digit = n % 10
        reverse = reverse * 10 + digit
        n //= 10
    return reverse

res_1 = reverse(n)
print(f"Число {n} наоборот {res_1}")
n = int(input("Введите второе число: "))
res_2 = reverse(n)
print(f"Число {n} наоборот {res_2}")
print(f"Сумма чисел {res_1} и {res_2} = {res_1+res_2}")
full_res = reverse(res_1+res_2)
print(f"Число {res_1+res_2} наоборот: {full_res}")


print('Задача 4. Недоделка 2')

# Вы всё так же работаете в конторе по разработке игр и смотрите различные
# программы прошлого горе-программиста. В одной из игр для детей, связанной с
# мультяшной работой с числами, вам нужно было написать код согласно следующим
# условиям: программа получает на вход два числа; в первом числе должно быть
# не менее трёх цифр, во втором — не менее четырёх, иначе программа выдаёт ошибку.
# Если всё нормально, то в каждом числе первая и последняя цифры меняются местами,
# а затем выводится их сумма.

# И тут вы натыкаетесь на программу, которая была написана предыдущим программистом
# и которая как раз решает такую задачу. Однако старший программист попросил вас
# немного переписать этот код, чтобы он не выглядел так ужасно. Да и вам самим
# становится, мягко говоря, не по себе от него.

# Постарайтесь разделить логику кода на три отдельные логические части (функции):
# count_numbers — получает число и возвращает количество цифр в числе;
# change_number — получает число, меняет в нём местами первую и последнюю цифры и
# возвращает изменённое число;
# main — функция ничего не получает на вход, внутри она запрашивает нужные данные
# от пользователя, выполняет дополнительные проверки и вызывает функции 1 и 2 для
# выполнения задачи (проверки и изменения двух чисел).

# Разбейте приведённую ниже программу на функции. Повторений кода должно быть
# как можно меньше. Также сделайте, чтобы в основной части программы был только
# ввод чисел, затем изменённые числа и вывод их суммы.



def main():
  n = int(
    input(
      "Введите первое число не менее 3-х знаков, второе не менее 4-х знаков: ")
  )
  while n < 100:
    n = int(
      input(
        "Введите число, а не буквы не менее 3-х знаков, второе не менее 4-х знаков: : "
      ))
  return n


def count_numbers():
  n_1 = main()
  if len(str(n_1)) >= 3:
    return n_1


def change_number():
  n_1 = count_numbers()
  n_1 = str(n_1)
  new_number = n_1[-1] + n_1[1:len(n_1) - 1] + n_1[0]
  return int(new_number)


new_number_1 = change_number()
print("Первое число с заменой:", new_number_1)
new_number_2 = change_number()
print("Второе число с заменой:", new_number_2)
print(f"Сумма измененных чисел = {new_number_1+new_number_2}")


print('Задача 5. Маятник ')

# Известно, что амплитуда качающегося маятника с каждым разом затухает
# на 8,4% от амплитуды прошлого колебания. 
# Если качнуть маятник,
# то, строго говоря, он не остановится никогда, 
# просто амплитуда будет постоянно уменьшаться до тех пор, 
# пока мы не сочтём такой маятник остановившимся. 
 
# Напишите программу, 
# определяющую, сколько раз качнётся маятник, прежде чем он, по нашему мнению,
# остановится. 
 
# Программа получает на вход
# начальную амплитуду колебания в сантиметрах 
# и конечную амплитуду его колебаний,
# которая считается остановкой маятника. 

# Обеспечьте контроль ввода.

# Пример:

# Введите начальную амплитуду: 1
# Введите амплитуду остановки: 0.1
 
# Маятник считается остановившимся через 27 колебаний

amplitude_start = int(input("Введите начальную амплитуду: "))
amplitude_stop = float(input("Введите амплитуду остановки: "))

while amplitude_start < 0 or 0 > amplitude_stop or amplitude_start < amplitude_stop:
    print("Значения должны быть положительные или амплитуда остановки превышает амплитуду старта")
    amplitude_start = int(input("Введите начальную амплитуду: "))
    amplitude_stop = float(input("Введите амплитуду остановки: "))

def amplitude(amplitude_start, amplitude_stop):
  counter = 0
  while amplitude_start >= amplitude_stop:
    amplitude_start -= amplitude_start / 100 * 8.4
    counter += 1
  print(counter)
  return counter


finish = amplitude(amplitude_start, amplitude_stop)
print("Маятник остановится через:", finish, "секунд")


print('Задача 6. Яйца')

# В рамках программы колонизации Марса
# компания «Спейс Инжиниринг» вывела особую породу черепах,
# которые, по задумке, должны размножаться, откладывая яйца в марсианском грунте.
# Откладывать яйца слишком близко к поверхности опасно из-за радиации,
# а слишком глубоко — из-за давления грунта и недостатка кислорода.
# Вообще, факторов очень много,
# но специалисты проделали большую работу и предположили,
# что уровень опасности для черепашьих яиц рассчитывается по формуле
# D = x**3 − 3x**2 − 12x + 10,
# где x — глубина кладки в метрах,
# а D — уровень опасности в условных единицах.
# 
# Для тестирования гипотезы
# нужно взять пробу грунта на безопасной, согласно формуле, глубине.
# 
# Напишите программу,
# находящую такое значение глубины "х", при котором уровень опасности как можно
# более близок к нулю.
# На вход программе подаётся максимально допустимое отклонение уровня
# опасности от нуля,
# а программа должна рассчитать приблизительное значение "х",
# удовлетворяющее этому отклонению.
# 
# Известно, что глубина точно больше нуля и меньше четырёх метров.
# 
# Обеспечьте контроль ввода.
# 
# Пример:
# Введите максимально допустимый уровень опасности: 0.01
# 
# Приблизительная глубина безопасной кладки: 0.732421875 м


danger = float(input("Введите максимально допустимый уровень опасности: "))

while danger < 0:
    print("Значение должно быть положительным")
    danger = float(input("Введите максимально допустимый уровень опасности: "))
    
def check_danger(danger):
    i = 4
    while danger != round(i**3 - 3*i**2 - 12*i +10, 2):
      i -= 0.0001
      if danger == round(i**3 - 3*i**2 - 12*i +10, 2):
        print("Значение в метраx", (round(i,15)))



check_danger(danger)
